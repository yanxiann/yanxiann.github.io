



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="Hexo" href="http://example.com/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="Hexo" href="http://example.com/atom.xml" />
<link rel="alternate" type="application/json" title="Hexo" href="http://example.com/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="Java" />


<link rel="canonical" href="http://example.com/2022/02/04/%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/">



  <title>
并发总结 |
研究导弹茶叶蛋 = Hexo</title>
<meta name="generator" content="Hexo 5.4.1"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">并发总结
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2022-02-04 18:08:25">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2022-02-04T18:08:25+08:00">2022-02-04</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">研究导弹茶叶蛋</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipex2cdtbj20zk0m8x6p.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gipexoj0moj20zk0m8kgu.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclhnx9glj20zk0m8npd.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicivghyooj20zk0m8dir.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclxp31goj20zk0m8qv5.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclhfehz7j20zk0m8u0x.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">Home</a></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/04/%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="导弹哥">
    <meta itemprop="description" content=", ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Hexo">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h3 id="1-使用线程"><a href="#1-使用线程" class="headerlink" title="1.使用线程"></a>1.使用线程</h3><p>有三种使用线程的方法：</p>
<ul>
<li><p>实现 Runnable 接口；</p>
</li>
<li><p>实现 Callable 接口；（1.5 中引入）</p>
</li>
<li><p>继承 Thread 类。（Thread 类也实现了 Runable 接口）</p>
</li>
<li><p>```java<br>public static void main(String[] args) {</p>
<pre><code>MyRunnable instance = new MyRunnable();
Thread thread = new Thread(instance);
thread.start();
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">实现 Runnable 接口需要实现接口中的 **run()** 方法。使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。</span><br><span class="line"></span><br><span class="line">（ **调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。**把 `run()` 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**实现 Runnable 比继承 Thread 类对比**</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  -适合多个相同的程序代码的线程去处理同一个资源</span><br><span class="line">  - 可以避免 java 中的单继承的限制</span><br><span class="line">  - 增加程序的健壮性，代码可以被多个线程共享，代码和数据独立</span><br><span class="line">  - 线程池只能放入实现 Runable 或 callable 类线程，不能直接放入继承 Thread 的类</span><br><span class="line">  - runnable 实现线程可以对线程进行复用，因为 runnable 是轻量级的对象，重复 new 不会耗费太大资源，而 Thread 则不然，它是**重量级**对象，而且线程执行完就完了，无法再次利用Runnable 与 Callable</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>Runnable 与 Callable</strong><br>相同点：1.都是接口  2.都可以编写多线程程序  3.都采用Thread.start()启动线程</p>
<p>不同点:Runnable没有返回值；Callable可以返回执行结果。Callable接口的call()允许抛出异常；Runnable的run()不能抛出</p>
<p><strong>Callable获取返回值</strong><br>Callalble接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</p>
<h3 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2.线程池"></a>2.线程池</h3><p><strong>降低资源消耗</strong>，<strong>提高响应速度</strong>，<strong>提高线程的可管理性</strong></p>
<p><code>Executor</code> 框架是 Java5 之后引进的，通过 <code>Executor</code> 来启动线程比使用 <code>Thread</code> 的 <code>start</code> 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。</p>
<blockquote>
<p>补充：this 逃逸是指在构造函数返回之前其他线程就持有该对象的引用. 调用尚未构造完全的对象的方法可能引发令人疑惑的错误。</p>
</blockquote>
<p><code>Executor</code> 框架不仅包括了线程池的管理，还提供了线程工厂、队列以及拒绝策略等，<code>Executor</code> 框架让并发编程变得更加简单。</p>
<p><strong>结构</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1) 任务(Runnable/Callable)</span><br><span class="line">执行任务需要实现的Runnable 接口或Callable接口。Runnable 接口或 Callable 接口 实现类都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。</span><br><span class="line"> 2) 任务的执行(Executor)</span><br><span class="line">包括任务执行机制的核心接口Executor，以及继承自Executor接口的 ExecutorService 接口。ThreadPoolExecutor和 ScheduledThreadPoolExecutor这两个关键类实现了 ExecutorService 接口。</span><br><span class="line"> 3) 异步计算的结果(Future)</span><br><span class="line">Future接口以及 Future接口的实现类FutureTask类都可以代表异步计算的结果。（调用 submit()方法时会返回一个 FutureTask 对象）</span><br><span class="line">​	主线程可以执行FutureTask.get()方法来等待任务执行完成。主线程也可以执行 FutureTask.cancel来取消此任务的执行。https://blog.csdn.net/qq_39654841/article/details/90631795</span><br></pre></td></tr></table></figure>

<p><u>为什么java线程池的submit既可以提交runnable也可以提交callable</u>？（无论是runnable还是callable，返回值都是future，通过newTaskFor进行了包装，返回了RunnableFuture，futuretask又实现了这个接口，所以自然就可以返回futuretask了。）<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhbnFpbmc0NTYvYXJ0aWNsZS9kZXRhaWxzLzEyMjMxMzQ5MD91dG1fbWVkaXVtPWRpc3RyaWJ1dGUucGNfYWdncGFnZV9zZWFyY2hfcmVzdWx0Lm5vbmUtdGFzay1ibG9nLTJ+YWdncmVnYXRlcGFnZX5maXJzdF9yYW5rX2VjcG1fdjF+cmFua192MzFfZWNwbS0yLTEyMjMxMzQ5MC5wY19hZ2dfbmV3X3JhbmsmYW1wO3V0bV90ZXJtPXJ1bm5hYmxlK3N1Ym1pdCZhbXA7c3BtPTEwMDAuMjEyMy4zMDAxLjQ0MzA=">https://blog.csdn.net/hanqing456/article/details/122313490?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-2-122313490.pc_agg_new_rank&amp;utm_term=runnable+submit&amp;spm=1000.2123.3001.4430</span></p>
<p><strong>ThreadPoolExecutor 类</strong></p>
<p><strong>参数：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- corePoolSize : 核心线程数线程数定义了最小可以同时运行的线程数量。</span><br><span class="line">- maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</span><br><span class="line">- workQueue:当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</span><br><span class="line">- keepAliveTime:当线程池中的线程数量大于 `corePoolSize` 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 `keepAliveTime`才会被回收销毁；</span><br><span class="line">- unit : keepAliveTime参数的时间单位。</span><br><span class="line">- threadFactory:executor 创建新线程的时候会用到。</span><br><span class="line">- handler :饱和策略。</span><br></pre></td></tr></table></figure>

<p><strong>饱和策略:</strong></p>
<ul>
<li>```<br>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时:<ul>
<li>AbortPolicy ：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li>CallerRunsPolicy ：调用执行自己的线程运行任务，也就是直接在调用execute方法的线程中运行(run)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。可以承受此延迟并且要求任何一个任务请求都要被执行。</li>
<li>DiscardPolicy ：不处理新任务，直接丢弃掉。</li>
<li>DiscardOldestPolicy ： 此策略将丢弃最早的未处理的任务请求。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**线程池原理**（execute）：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">1.首先判断当前线程池中之行的任务数量是否小于 corePoolSize</span><br><span class="line">2.如果当前之行的任务数量大于等于 corePoolSize 且队列可以加入任务</span><br><span class="line">3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span><br><span class="line">addWorker 这个方法主要用来创建新的工作线程，如果返回 true 说明创建和启动工作线程成功，否则的话返回的就是 false。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>常见线程池</strong></p>
<p><strong>FixedThreadPool</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line">-如果当前运行的线程数小于 corePoolSize， 如果再来新任务的话，就创建新的线程来执行任务；</span><br><span class="line">-当前运行的线程数等于 corePoolSize 后， 如果再来新任务的话，会将任务加入 LinkedBlockingQueue；</span><br><span class="line">-线程池中的线程执行完 手头的任务后，会在循环中反复从 (无界队列)LinkedBlockingQueue 中获取任务来执行；</span><br></pre></td></tr></table></figure>

<p><strong>SingleThreadExecutor</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                    threadFactory));</span><br><span class="line">如果当前运行的线程数少于 corePoolSize，则创建一个新的线程执行任务；</span><br><span class="line">当前线程池中有一个运行的线程后，将任务加入 LinkedBlockingQueue</span><br><span class="line">线程执行完当前的任务后，会在循环中反复从(无界队列）LinkedBlockingQueue 中获取任务来执行；</span><br></pre></td></tr></table></figure>

<p><strong>CachedThreadPool</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;(),</span><br><span class="line">                                      threadFactory);</span><br><span class="line"><span class="number">1.</span>首先执行 SynchronousQueue.offer(Runnable task) 提交任务到任务队列。如果当前 maximumPool 中有闲线程正在执行 SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)，那么主线程执行 offer 操作与空闲线程执行的 poll 操作配对成功，主线程把任务交给空闲线程执行，execute()方法执行完成</span><br><span class="line"><span class="number">2</span>；当初始 maximumPool 为空，或者 maximumPool 中没有空闲线程时，将没有线程执行 SynchronousQueue.poll(keepAliveTime,TimeUnit.NANOSECONDS)。这种情况下，步骤 <span class="number">1</span> 将失败，此时 CachedThreadPool 会创建新线程执行任务，execute 方法执行完成；</span><br></pre></td></tr></table></figure>

<p><strong>ScheduledThreadPoolExecutor</strong></p>
<p><strong>主要用来在给定的延迟后运行任务，或者定期执行任务</strong></p>
<p>任务队列 <code>DelayQueue</code> 封装了一个 <strong>PriorityQueue</strong>，<code>PriorityQueue</code> 会对队列中的任务进行排序，执行所需时间短的放在前面先被执行(<code>ScheduledFutureTask</code> 的 <code>time</code> 变量小的先执行)，如果执行所需时间相同则先提交的任务将被先执行(<code>ScheduledFutureTask</code> 的 <code>squenceNumber</code> 变量小的先执行)。</p>
<p><strong>线程池大小确定</strong></p>
<ul>
<li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li>
<li><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li>
</ul>
<h3 id="3-线程间交互"><a href="#3-线程间交互" class="headerlink" title="3.线程间交互"></a>3.线程间交互</h3><p><strong>线程死锁</strong></p>
<ol>
<li>互斥条件：该资源任意一个时刻只由一个线程占用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<p><strong>如何预防死锁？</strong> 破坏死锁的产生的必要条件即可：</p>
<ol>
<li><strong>破坏请求与保持条件</strong> ：一次性申请所有的资源。</li>
<li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ol>
<p><strong>Daemon</strong></p>
<p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p>
<p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</p>
<p>在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程。</p>
<p><strong>暂停线程</strong></p>
<p>​    sleep() 方法没有释放锁，而 wait() 方法释放了锁 。</p>
<p>​    wait()<code> 通常被用于线程间交互/通信，</code>sleep() <code>通常被用于暂停执行。</code></p>
<p><code>    wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify() </code>或者 <code>notifyAll()</code> 方法。<code>sleep() </code>方法执行完成后，线程会自动苏醒。或者可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</p>
<p><strong>中断线程</strong></p>
<p>InterruptedException通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p>
<p>调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p>
<p>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，而 shutdownNow 会给所有线程发送中断信号，中断任务执行，然后关闭线程池。</p>
<p><strong>线程协作</strong></p>
<p>**join()**在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p>
<p><strong>wait() notify() notifyAll()</strong></p>
<p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。</p>
<p><strong>await() signal() signalAll()</strong></p>
<p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p>
<h3 id="4-锁"><a href="#4-锁" class="headerlink" title="4.锁"></a>4.锁</h3><p><strong>CAS(Compare And Swap)</strong></p>
<p><strong>CAS的概念</strong></p>
<ol>
<li>CAS是一种高效实现线程安全性的方法，支持原子更新操作、计数器、序列发生器等场景</li>
<li>属于乐观锁机制，号称Lock-Free</li>
<li>CAS操作失败时由开发者决定是否重试，还是执行别的操作</li>
</ol>
<p><strong>CAS实现机制</strong></p>
<p>通过本地方法<code>Unsafe.getUnsafe().objectFieldOffset</code>获取值在内存中的偏移量；</p>
<p>然后又通过本地方法<code>unsafe.compareAndSwapInt</code> 去更新数据；如果内存中的值跟期望中的值一样则 修改成update；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内存中value的偏移量 </span></span><br><span class="line"><span class="type">long</span> <span class="variable">valueOffset</span> <span class="operator">=</span> Unsafe.getUnsafe().objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="built_in">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CAS的ABA问题</strong></p>
<p>如果线程1从内存X中取出A，这时候另一个线程2也从内存X中取出A，并且线程2进行了一些操作将内存X中的值变成了B，然后线程2又将内存X中的 数据变成A，这时候线程1进行CAS操作发现内存X中仍然是A，然后线程1操作成功。虽然线程1的CAS操作成功，但是整个过程就是有问题的。</p>
<p>比如链表的头在变化了两次后恢复了原值，但是不代表链表就没有变化</p>
<p>所以JAVA中提供了<code>AtomicStampedReference/AtomicMarkableReference</code>来处理会发生ABA问题的场景，<strong>主要是在对象中额外再增加一个标记来标识对象是否有过变更</strong></p>
<h4 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a><strong>synchronized 关键字</strong></h4><ul>
<li>```<ul>
<li>synchronized有什么用</li>
<li>对象在内存中的布局</li>
<li>JDK1.6对synchronized的优化</li>
<li>自旋锁与自适应自旋锁</li>
<li>synchronized底层实现原理</li>
<li>ReentrantLock和synchronized的区别<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**synchronized有什么用**</span><br><span class="line"></span><br><span class="line">`synchronized` 关键字解决的是多个线程之间访问资源的同步性，`synchronized`关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</span><br><span class="line"></span><br><span class="line">在 Java 早期版本中，`synchronized` 属于 **重量级锁**，效率低下（需要操作系统帮忙）。</span><br><span class="line"></span><br><span class="line">synchronized锁的都是对象，可分为两种锁：对象锁和类锁，类锁是一种特殊的对象锁 </span><br><span class="line"></span><br><span class="line">1. 对象锁：可通过synchronized(this)&#123;&#125;方式进行代码块的对象锁，在非静态方法上添加synchronized关键字可进行方法的对象锁</span><br><span class="line">2. 类锁：通过synchronized(类.class)&#123;&#125;方式进行代码块的类锁，在静态方法上添加synchronized关键字可进行方法的类锁，由于类只有一把类锁，所以不同对象使用类锁将会是同步的对象锁和类锁互不干扰</span><br><span class="line"></span><br><span class="line">- 原子性：同时只允许一个线程持有某个对象锁</span><br><span class="line"></span><br><span class="line">- 可见性：锁在释放之前对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的    </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">**对象在内存中的布局**</span><br><span class="line"></span><br><span class="line">- 在HotSpot虚拟机中, 对象在内存中的布局分为三块区域: 对象头, 实例数据和对齐填充.</span><br><span class="line">- 对象头中包含两部分: MarkWord 和 类型指针</span><br><span class="line"></span><br><span class="line">- 实例数据：**实例数据部分是对象真正存储的有效信息**，也是在程序中所定义的各种类型的字段内容。</span><br><span class="line"></span><br><span class="line">- 对其填充：用于填充对象的结构，没有实际意义。因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是**对象的大小必须是 8 字节的整数倍**。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</span><br><span class="line"></span><br><span class="line">- monitor：每个Java对象天生自带的内部锁，monitor对象存在每个对象的对象头中 </span><br><span class="line"></span><br><span class="line">- synchronized的可重入性：获得当前对象锁的情况下，再次请求此对象锁，这种情况属于重入。</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">**JDK1.6对synchronized的优化**</span><br><span class="line"></span><br><span class="line">- 在JDK1.5及以前的版本中，synchronized 属于重量级锁，依赖于Mutex Lock实现，挂起线程和恢复线程的操作都需要从用户态转入**内核态**中完成，这些操作给系统的并发性能带来了很大的压力</span><br><span class="line"></span><br><span class="line">1. javaSE1.6引入了偏向锁（Biased Locking）、自旋锁（自适应自旋：Adaptive Spinning）、轻量级锁（Lightweight Locking）后，synchronized和ReentrantLock两者的性能就差不多了</span><br><span class="line">   锁可以升级, 但不能降级. 即: **无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁是单向的.**</span><br><span class="line"></span><br><span class="line">2. 偏向锁（Biased Locking）</span><br><span class="line"></span><br><span class="line">   `偏向锁`: HotSpot的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得; **偏向锁是四种状态中最乐观的一种锁：从始至终只有一个线程请求某一把锁。**</span><br><span class="line">    **`偏向锁的获取`:** 当一个线程访问同步块并成功获取到锁时，会在**对象头**和**栈帧中的锁记录**字段里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，直接进入</span><br><span class="line">    **`偏性锁的撤销:`** 偏向锁使用了一种等待竞争出现才释放锁的机制，所以当其他线程竞争偏向锁时，持有偏向锁的线程才会释放偏向锁，并将锁膨胀为轻量级锁（持有偏向锁的线程依然存活的时候）</span><br><span class="line"></span><br><span class="line">3. 轻量级锁（Lightweight Locking）</span><br><span class="line"></span><br><span class="line">   **多个线程在不同的时间段请求同一把锁，也就是说没有锁竞争**。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
1、线程1持有偏向级锁；<br>2、线程2来竞争锁对象;<br>3、判断当前对象头是否是偏向锁;<br>4、判断拥有偏向锁的线程1是否还存在;<br>线程1不存在,直接设置偏向锁标识为0(线程1执行完毕后,不会主动去释放偏向锁)。使用cas替换偏向锁线程ID为线程2,锁不升级，仍为偏向锁;<br>线程1仍然存在,暂停线程1。设置锁标志位为00(变为轻量级锁),偏向锁为0;<br>5、从线程1的空闲monitor record中读取一条,放至线程1的当前monitor record中;<br>6、更新mark word，将mark word指向线程1中monitor record的指针;<br>7、继续执行线程1的代码;<br>8、锁升级为轻量级锁;<br>9、线程2自旋来获取锁对象;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   1. 在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前**线程的栈帧**中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。</span><br><span class="line">   2. 拷贝对象头中的Mark Word复制到锁记录中；</span><br><span class="line">   3. 拷贝成功后，虚拟机将使用**CAS**操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤4，否则执行步骤5。</span><br><span class="line">   4. 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态，</span><br><span class="line">   5. 如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 而当前线程便尝试使用**自旋**来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。</span><br><span class="line"></span><br><span class="line">    `解锁:`轻量级锁解锁时, 会使用原子的CAS操作将当前线程的锁记录替换回到对象头, 如果成功, 表示没有竞争发生; 如果失败, 表示当前锁存在竞争, 锁就会膨胀成重量级锁</span><br><span class="line"></span><br><span class="line">4. 重量级锁</span><br><span class="line"></span><br><span class="line">   Java线程的阻塞以及唤醒，都是依靠操作系统来完成的,这些操作将涉及系统调用，需要从操作系统的用户态切换至内核态，其开销非常之大。</span><br><span class="line"></span><br><span class="line">5. 其他优化</span><br><span class="line"></span><br><span class="line">   `锁粗化:`锁粗化（Lock Coarsening）就是将多次连接在一起的加锁、解锁操作合并为一次，将多个连续的锁扩展成为一个范围更大的锁</span><br><span class="line">    `锁消除:`锁消除（Lock Eliminate）即删除不必要的加锁操作。根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸出当前线程， 那么可以认为这段代码是线程安全的，不必要加锁</span><br><span class="line"></span><br><span class="line">   https://blog.csdn.net/weixin_43767015/article/details/105544786</span><br><span class="line"></span><br><span class="line">**自旋锁与自适应自旋锁**</span><br><span class="line"></span><br><span class="line">自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就**避免用户线程和内核的切换的消耗**。</span><br><span class="line"></span><br><span class="line">但是线程自旋是需要消耗cup的，说白了就是让cup在做无用功，如果一直获取不到锁，那线程也不能一直占用cup自旋做无用功，所以需要设定一个自旋等待的最大时间。</span><br><span class="line"></span><br><span class="line">如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。</span><br><span class="line"></span><br><span class="line">&gt; 自适应自旋锁：自旋的次数不再固定，由前一次在同一个上的自旋时间及锁的拥有者的状态来决定</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**synchronized底层实现原理**</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  - synchronized同步代码块</span><br><span class="line">  - synchronized静态方法块</span><br><span class="line">  - synchronized实例方法块</span><br><span class="line">  - synchronized底层实现原理</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>synchronized同步代码块</strong></p>
<p>指定加锁对象，对给定对象/类加锁。<code>synchronized(this|object)</code> 表示进入同步代码库前要获得<strong>给定对象的锁</strong>。<code>synchronized(类.class)</code> 表示进入同步代码前要获得 **当前 class 的锁 **</p>
<p>底层字节码指令：进入前执行monitorenter指令、退出后执行monitorexit指令</p>
<p><strong>静态方法块</strong></p>
<p>也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。</p>
<p>访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁。</p>
<p>底层指令：方法被ACC_SYNCRONIZED标记</p>
<p><strong>synchronized实例方法块</strong></p>
<p>作用于当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong></p>
<p>底层指令：ACC_SYNCRONIZED标记</p>
<p><strong>synchronized底层实现原理</strong></p>
<p><code>synchronized</code>底层是由<code>monitor</code>对象来完成的，monitor对象也就是内部锁，存在于每个Java对象的对象头中。底层实现原理根据synchronized的用法可以分为两种，但底层实现其实都一样。</p>
<p>当synchronized用在同步块上的时候，线程会尝试执行<code>monitorenter</code>，获取monitor的所有权，也就是获取该对象的锁。每个monitorenter指令都有对应的<code>monitorexit</code>指令，也就相当于释放锁。</p>
<p>moniterenter指令使锁计数加一，monitorexit指令使锁计数减一，当锁计数减为0后，线程退出monitor，相当于把锁释放。当synchronized用在同步方法上时，是根据常量池中的ACC_SYNCHRONIZED标识符来实现方法同步的，如果这个标识符被设置就执行线程获取monitor对象也就是加锁，然后执行方法体，执行完毕后释放monitor也就是解锁。</p>
<p><strong>ReentrantLock和synchronized的区别</strong></p>
<ol>
<li>都是<strong>悲观锁</strong>，虽然synchronized包含偏向锁、轻量级锁、重量级锁，但它们都属于悲观锁，这些锁虽然有的用到了cas,但这只是获得锁的方式不一样。（悲观锁与乐观锁的区别在于是否锁定资源，乐观锁通过cas,版本号的方式替代直接锁定资源的方式，并不是严格意义的锁。）</li>
<li>都是<strong>可重入锁</strong>，“可重入锁”** 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</li>
<li>synchronized是依赖于 <strong>JVM</strong> 实现的，ReentrantLock是 <strong>JDK</strong> 层面实现的。</li>
<li>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。：<ul>
<li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li>
<li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和notify()<code>/</code>notifyAll()方法相结合可以实现等待/通知机制。ReentrantLock类当然也可以实现，但是需要借助于<code>Condition</code>接口与newCondition()方法。</li>
</ul>
</li>
</ol>
<blockquote>
<p>名词解释</p>
<ul>
<li>公平锁：获取锁的顺序按先后调用lock()方法的顺序（慎用）</li>
<li>非公平锁：视线程的抢占能力而言，先到先得<ol>
<li>非公平锁在调用 lock 后，首先就会调用 CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。</li>
<li>非公平锁在 CAS 失败后，和公平锁一样都会进入到 <code>tryAcquire</code> 方法，在 <code>tryAcquire</code> 方法中，如果发现锁这个时候被释放了（state == 0），非公平锁会直接 CAS 抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到后面。</li>
</ol>
</li>
</ul>
</blockquote>
<h4 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a><strong>AQS</strong></h4><p>AQS，AbstractQueuedSynchronizer 类如其名，是一个<strong>抽象队列同步器</strong>。<u>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</u></p>
<p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出大量应用广泛的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>，<code>FutureTask</code> 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。</p>
<p>  AQS 使用一个 int 成员变量来表示<strong>同步状态</strong>，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。<strong>（资源的状态，获取不到state就加入队列）</strong></p>
<p>状态信息通过 <code>protected</code> 类型的<code>getState()</code>，<code>setState()</code>，<code>compareAndSetState()</code> 进行操作</p>
<p><strong>AQS 定义两种资源共享方式</strong></p>
<ol>
<li><strong>Exclusive</strong>（独占）：只有一个线程能执行，如ReentrantLock。</li>
<li><strong>Share</strong>（共享）多个线程可同时执行，如 <code>Semaphore/CountDownLatch</code>。<code>Semaphore</code>、<code>CountDownLatch</code>、 <code>CyclicBarrier</code>、<code>ReadWriteLock</code> 。</li>
<li><code>ReentrantReadWriteLock</code> 可以看成是组合式，因为 <code>ReentrantReadWriteLock</code> 也就是读写锁允许多个线程同时对某一资源进行读。<ul>
<li><strong>公平锁</strong> ：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li><strong>非公平锁</strong> ：当线程要获取锁时，先通过两次 CAS 操作去抢锁，如果没抢到，当前线程再加入到队列中等待唤醒。</li>
</ul>
</li>
</ol>
<p><strong>AQS 底层使用了模板方法模式</strong></p>
<p> 如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>
<ol>
<li><p>使用者继承 <code>AbstractQueuedSynchronizer</code> 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）</p>
</li>
<li><p>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</p>
</li>
<li><p><strong>自定义同步器时需要重写下面几个 AQS 提供的钩子方法</strong></p>
</li>
<li><p>```java<br>protected boolean tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。<br>protected boolean tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。<br>protected boolean tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。<br>protected boolean tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。<br>protected boolean isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**什么是钩子方法呢？** 钩子方法是一种被声明在抽象类中的方法，一般使用 `protected` 关键字修饰，它可以是空方法（由子类实现），也可以是默认实现的方法。模板设计模式通过钩子方法控制固定步骤的实现。</span><br><span class="line"></span><br><span class="line">以 `ReentrantLock` 为例，state 初始化为 0，表示未锁定状态。A 线程 `lock()` 时，会调用 `tryAcquire()` 独占该锁并将 `state+1` 。此后，其他线程再 `tryAcquire()` 时就会失败，直到 A 线程 `unlock()` 到 `state=`0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的。</span><br><span class="line"></span><br><span class="line">再以 `CountDownLatch` 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后` countDown()` 一次，state 会 CAS(Compare and Swap) 减 1。等到所有子线程都执行完后(即 `state=0` )，会 `unpark()` 主调用线程，然后主调用线程就会从 `await()` 函数返回，继续后余动作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**Semaphore(信号量)**</span><br><span class="line"></span><br><span class="line">`synchronized` 和 `ReentrantLock` 都是一次只允许一个线程访问某个资源，`Semaphore`(信号量)可以指定多个线程同时访问某个资源。</span><br><span class="line"></span><br><span class="line">`Semaphore` 只是维持了一个可获得许可证的数量。 `Semaphore` 经常用于**限制获取某种资源的线程数量**</span><br><span class="line"></span><br><span class="line">`Semaphore` 有两种模式，公平模式和非公平模式。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**CountDownLatch （倒计时器）**</span><br><span class="line"></span><br><span class="line">允许 `count` 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</span><br><span class="line"></span><br><span class="line">是共享锁的一种实现,它默认构造 AQS 的 `state` 值为 `count`。当线程使用 `countDown()` 方法时,其实使用了`tryReleaseShared`方法以 CAS 的操作来减少 `state`,直至 `state` 为 0 。当调用 `await()` 方法的时候，如果 `state` 不为 0，那就证明任务还没有执行完毕，`await()` 方法就会一直阻塞，也就是说 `await()` 方法之后的语句不会被执行。然后，`CountDownLatch` 会自旋 CAS 判断 `state == 0`，如果 `state == 0` 的话，就会释放所有等待的线程，`await()` 方法之后的语句得到执行。</span><br><span class="line"></span><br><span class="line">**1、某一线程在开始运行前等待 n 个线程执行完毕。**</span><br><span class="line"></span><br><span class="line">**2、实现多个线程开始执行任务的最大并行性。**</span><br><span class="line"></span><br><span class="line">`CountDownLatch` 是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当 `CountDownLatch` 使用完毕后，它不能再次被使用。</span><br><span class="line"></span><br><span class="line">可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个 Excel 保存了用户所有银行流水，每个 Sheet 保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个 sheet 里的银行流水，都执行完之后，得到每个 sheet 的日均银行流水，最后，再用 barrierAction 用这些线程的计算结果，计算出整个 Excel 的日均银行流水。</span><br><span class="line"></span><br><span class="line">**CyclicBarrier(循环栅栏)**</span><br><span class="line"></span><br><span class="line">可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。</span><br><span class="line"></span><br><span class="line">`CyclicBarrier` 内部通过一个 count 变量作为计数器，count 的初始值为 parties 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减一。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</span><br><span class="line"></span><br><span class="line">**区别:**CountDownLatch` 是计数器，只能使用一次，而 `CyclicBarrier` 的计数器提供 `reset` 功能，可以多次使用。CountDownLatch: 一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；CyclicBarrier : 多个线程互相等待，直到到达同一个同步点，再继续一起执行。</span><br><span class="line"></span><br><span class="line">**J.U.C包的分类**</span><br><span class="line"></span><br><span class="line">1. 线程执行器**executor**</span><br><span class="line">2. 锁**locks**</span><br><span class="line">3. 原子变量类**atomic**</span><br><span class="line">4. 并发工具类**tools**</span><br><span class="line">5. 并发集合**collections**</span><br><span class="line"></span><br><span class="line">### **5.线程安全的实现**</span><br><span class="line"></span><br><span class="line">**并发容器**</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>ConcurrentHashMap : 线程安全的 HashMap</li>
<li>CopyOnWriteArrayList : 线程安全的 List，在读多写少的场合性能非常好，远远好于 Vector。</li>
<li>ConcurrentLinkedQueue : 高效的并发队列，使用链表实现。可以看做一个线程安全的 LinkedList，这是一个非阻塞队列。</li>
<li>BlockingQueue: 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。</li>
<li>ConcurrentSkipListMap: 跳表的实现。这是一个 Map，使用跳表的数据结构进行快速查找。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**CopyOnWriteArrayList**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
只有写入和写入之间需要进行同步等待<br>CopyOnWrite也就是说：如果你想要对一块内存进行修改时，我们不在原有内存块中进行写操作，而是将内存拷贝一份，在新的内存中进行写操作，写完之后呢，就将指向原来内存指针指向新的内存，原来的内存就可以被回收掉了。<br>CopyOnWriteArrayList 写入操作 add()方法在添加集合的时候加了锁，保证了同步，避免了多线程写的时候会 copy 出多个副本出来。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**ConcurrentLinkedQueue**</span><br><span class="line"></span><br><span class="line">使用 CAS 非阻塞算法来实现线程安全，无锁，**非阻塞队列**，性能最好的队列</span><br><span class="line"></span><br><span class="line">**BlockingQueue** </span><br><span class="line"></span><br><span class="line">阻塞队列（`BlockingQueue`）被广泛使用在“生产者-消费者”问题中，其原因是 `BlockingQueue` 提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
ArrayBlockingQueue<br>有界队列实现类，底层采用数组。 一旦创建，容量不能改变。并发控制采用可重入锁 <code>ReentrantLock</code><br>LinkedBlockingQueue<br>单向链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用，具有更高的吞吐量<br>PriorityBlockingQueue<br>支持优先级的无界阻塞队列，并发控制采用的是可重入锁 <code>ReentrantLock</code>，队列为无界队列<br>```</li>
</ul>
<p><strong>ConcurrentSkipListMap</strong></p>
<p>跳表是一种利用空间换时间的算法。</p>
<p>使用跳表实现 <code>Map</code> 和使用哈希算法实现 <code>Map</code> 的另外一个不同之处是：哈希并不会保存元素的顺序，而跳表内所有的元素都是排序的。因此在对跳表进行遍历时，你会得到一个有序的结果。</p>
<p><strong>并发编程的三个重要特性</strong></p>
<ol>
<li><strong>原子性</strong> : 一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。<code>synchronized</code> 可以保证代码片段的原子性。</li>
<li><strong>可见性</strong> ：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。<code>volatile</code> 关键字可以保证共享变量的可见性。</li>
<li><strong>有序性</strong> ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化。</li>
</ol>
<p><strong>volatile</strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>
<p><strong>synchronized</strong> 关键字和 <strong>volatile</strong> 关键字是两个互补的存在，而不是对立的存在！</p>
<ul>
<li><p>volatile 关键字是线程同步的<strong>轻量级实现</strong>，所以 volatile <strong>性能</strong>肯定比synchronized关键字要好。但是 volatile 关键字只能用于<strong>变量</strong>，而 synchronized 关键字可以修饰<strong>方法</strong>以及<strong>代码块</strong> 。</p>
</li>
<li><p>volatile 关键字能保证数据的<strong>可见性</strong>，但不能保证数据的原子性。synchronized 关键字<strong>两者</strong>都能保证。</p>
</li>
<li><p>volatile关键字主要用于解决<strong>变量</strong>在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间<strong>访问资源</strong>的同步性。</p>
</li>
</ul>
<p><strong>ThreadLocal</strong></p>
<p>创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get（） 和 set（） 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p>
<p>最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。ThrealLocal<code> 类中可以通过</code>Thread.currentThread()<code>获取到当前线程对象后，直接通过</code>getMap(Thread t)<code>可以访问到该线程的</code>ThreadLocalMap`对象。</p>
<p><strong>每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为 key ，Object 对象为 value 的键值对。</strong></p>
<p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用,而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p>
<p><strong>Atomic 原子类</strong></p>
<p>原子类说简单点就是具有原子/原子操作特征的类。</p>
<p><strong>基本类型</strong> <strong>数组类型</strong> <strong>引用类型</strong> <strong>对象的属性修改类型</strong></p>
<p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>

      <div class="tags">
          <a href="/tags/Java/" rel="tag"><i class="ic i-tag"></i> Java</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2022-04-05 20:41:05" itemprop="dateModified" datetime="2022-04-05T20:41:05+08:00">2022-04-05</time>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> Donate</button>
  <p>Give me a cup of [coffee]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wechatpay.png" alt="导弹哥 WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div>
        <img data-src="/images/alipay.png" alt="导弹哥 Alipay">
        <p>Alipay</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>导弹哥 <i class="ic i-at"><em>@</em></i>Hexo
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="http://example.com/2022/02/04/%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/" title="并发总结">http://example.com/2022/02/04/并发总结/</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
    </div>
    <div class="item right">
      

  <a href="/2022/04/04/Map%E9%80%9F%E8%AE%B0/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipey0a334j20zk0m8qpt.jpg" title="Map速记">
  <span class="type">Next Post</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>Map速记</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">1.使用线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.</span> <span class="toc-text">2.线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E9%97%B4%E4%BA%A4%E4%BA%92"><span class="toc-number">3.</span> <span class="toc-text">3.线程间交互</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%94%81"><span class="toc-number">4.</span> <span class="toc-text">4.锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.1.</span> <span class="toc-text">synchronized 关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AQS"><span class="toc-number">4.2.</span> <span class="toc-text">AQS</span></a></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="导弹哥"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">导弹哥</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">3</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">1</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item email" data-url="bWFpbHRvOnlhbl94aWFuQGZveG1haWwuY29t" title="mailto:yan_xian@foxmail.com"><i class="ic i-envelope"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2022/04/06/http%E5%8D%8F%E8%AE%AE%E5%B0%8F%E8%AE%B0/" title="http协议小记">http协议小记</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2022/02/04/%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/" title="并发总结">并发总结</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2022/04/04/Map%E9%80%9F%E8%AE%B0/" title="Map速记">Map速记</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>Recent Comments</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2022</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">导弹哥 @ 研究导弹茶叶蛋</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2022/02/04/并发总结/',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,
    copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
