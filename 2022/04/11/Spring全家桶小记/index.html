



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="Hexo" href="http://example.com/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="Hexo" href="http://example.com/atom.xml" />
<link rel="alternate" type="application/json" title="Hexo" href="http://example.com/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="Java" />


<link rel="canonical" href="http://example.com/2022/04/11/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%B0%8F%E8%AE%B0/">



  <title>
Spring全家桶速记 |
研究导弹茶叶蛋 = Hexo</title>
<meta name="generator" content="Hexo 5.4.1"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">Spring全家桶速记
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2022-04-11 11:14:28">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2022-04-11T11:14:28+08:00">2022-04-11</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">研究导弹茶叶蛋</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giciukx8a7j20zk0m8aio.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giph4wqtg4j20zk0m8x6p.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipesng5oej20zk0m87d4.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipeu7txpzj20zk0m81kx.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipetv6p75j20zk0m8x6p.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipeyhsblkj20zk0m81kx.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">Home</a></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/11/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%B0%8F%E8%AE%B0/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="导弹哥">
    <meta itemprop="description" content=", ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Hexo">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</p>
<h4 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h4><p><strong>介绍：</strong>控制反转，把传统上由程序控制对象的权力交给容器，通过容器实现对象的装配和管理。所谓控制反转就是对组件控制权的转移，从代码本身转移到了外部容器。具体操作是把底层类作为参数传给上层，实现上层对下层的控制。而一般创建对象是通过new从底层往上层获得的  。</p>
<p>ioc负责创建对象，通过di来 管理、组合、配置对象以及控制对象的生命周期。</p>
<p>Ioc可以说是一种设计思想或者模式。也就是将控制权交给spring框架。Ioc容器是实现ioc的载体，实际上就是map。<strong>ioc的实现方式叫做DI。</strong>DI可以通过set，接口，注解，构造器注入实现。以前ioc的实现用到了dl（依赖查找）：通过容器的API来查找资源。无法在容器外使用。而依赖注入（Dependency Injection），即是组件之间的依赖关系由容器在应用程序<strong>运行期间</strong>决定，也就是说，由容器动态地将某种依赖关系的目标对象实例注入到应用程序中的各个关联的组件。组件本身不做定位查询，只提供普通的Java方法让容器去决定依赖关系</p>
<p><strong>用处：</strong>管理对象的创建和依赖的维护，解耦，代理了类的生产过程。<img data-src="C:\Users\yanxi\AppData\Roaming\Typora\typora-user-images\1649471279075.png" alt="1649471279075"></p>
<h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a><strong>AOP</strong></h4><p>面向切面编程，AOP 是 OOP（面向对象编程）的一种延续。OOP 编程思想可以解决大部分的代码重复问题。但是有一些问题是处理不了的。比如在父类 Animal 中的多个方法的相同位置出现了重复的代码，OOP 就解决不了。</p>
<p>AOP 主要用来解决：在不改变原有业务逻辑的情况下，增强横切逻辑代码，根本上解耦合，避免横切逻辑代码重复。</p>
<p><strong>切</strong> ：指的是横切逻辑，原有业务逻辑代码不动，只能操作横切逻辑代码，所以面向横切逻辑</p>
<p><strong>面</strong> ：横切逻辑代码往往要影响的是很多个方法，每个方法如同一个点，多个点构成一个面。这里有一个面的概念</p>
<blockquote>
<p>AOP的三种织入方式</p>
</blockquote>
<p>编译时织入：需要特殊的Java编译器，如<strong>AspectJ</strong></p>
<p>类加载时织入：需要特殊的java编译器和类加载器，如AspectJ和AspectWerkz</p>
<p>运行时织入：Spring采用的方式，通过JDK动态代理，实现简单</p>
<blockquote>
<p>动态代理</p>
</blockquote>
<p>主要有两种：JDK动态代理和CGlib（Code Generation Library：代码生成库），如果目标类为接口，使用JDKProxy来实现，否则使用CGlib。</p>
<ul>
<li>JDK动态代理主要通过Java语言内部的反射机制来实现的，在<strong>生成类</strong>的过程中比较高效</li>
<li>CGlib主要以继承的方式动态生成目标类的代理，借助ASM实现，生成类之后<strong>执行类</strong>的过程中比较高效</li>
</ul>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a><strong>事务</strong></h4><ul>
<li><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，</li>
<li><strong>隔离性（Isolation）：</strong> 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括脏读（Read uncommitted）、读已提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li><strong>持久性（Durability）:</strong> 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<p>分编程式事务管理和声明式事务管理（即手动和自动的区别）</p>
<p><strong>Spring 并不直接管理事务，而是提供了多种事务管理器</strong> 。</p>
<p><strong>事务属性</strong>包含了 5 个方面：</p>
<ul>
<li>隔离级别</li>
<li>传播行为</li>
<li>回滚规则</li>
<li>是否只读</li>
<li>事务超时</li>
</ul>
<p><strong>事务传播行为是为了解决业务层方法之间互相调用的事务问题</strong>。</p>
<p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。</p>
<p><strong>required</strong>（Propagation.REQUIRED ）<br>如果有事务, 那么加入事务, 没有的话新建一个(默认情况下)<br><strong>not_supported</strong>（Propagation.NOT_SUPPORTED)<br>容器不为这个方法开启事务<br><strong>requires_new</strong>(Propagation.REQUIRES_NEW)<br>不管是否存在事务,都创建一个新的事务,原来的挂起,新的执行完毕,继续执行老的事务<br>mandatory(Propagation.MANDATORY)<br>必须在一个已有的事务中执行,否则抛出异常<br>never(Propagation.NEVER)<br>必须在一个没有的事务中执行,否则抛出异常(与Propagation.MANDATORY相反)<br>supports(Propagation.SUPPORTS)<br>如果其他bean调用这个方法,在其他bean中声明事务,那就用事务.如果其他bean没有声明事务,那就不用事务.</p>
<p><strong>事务隔离级别</strong></p>
<p>读未提交：导致脏读，不可重复读，幻读</p>
<p>读已提交（大部分数据库）：导致不可重复读，幻读</p>
<p>可重复读（InnoDB 默认）：导致幻读</p>
<p>串行化：防止全部</p>
<h4 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h4><p><strong>作用域</strong></p>
<p>Singleton：Spring默认作用域，容器里拥有唯一bean实例，适合无状态的bean</p>
<p>Prototype：每个getbean请求都会创建一个bean实例，适合有状态的bean</p>
<p>Web容器支持另外三种作用域：</p>
<p>Request：会为每个HTTP请求创建一个bean实例</p>
<p>Session：会为每个Session请求创建一个bean实例</p>
<p>GolbalSession：会为每个全局HTTP Session创建一个bean实例，该作用域仅对Protlet有效</p>
<p><strong>生命周期</strong></p>
<ol>
<li>无参构造实例化Bean对象</li>
<li>set设置Bean属性</li>
<li>Aware（注入beanID，Beanfactory和AppCtx可以在bean中获取到ioc容器）如果通过Aware接口声明了依赖关系，则会注入基础层面的依赖</li>
<li>初始化之前执行的方法（对实例化的bean添加一些自定义处理逻辑）</li>
<li>afterPropertiesSet（属性被设置之后自定义的事情）</li>
<li>初始化Bean init方法</li>
<li>初始化后方法</li>
<li>获取bean实例</li>
<li>destroy()方法</li>
</ol>
<p><strong>单例Bean线程安全</strong></p>
<ol>
<li>在 bean 中尽量避免定义可变的成员变量。</li>
<li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li>
</ol>
<p>不过，大部分 bean 实际都是无状态（没有实例变量）的（比如 Dao、Service），这种情况下， bean 是线程安全的。</p>
<h4 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h4><p>​    循环依赖说白了是一个或多个对象实例之间存在直接或间接的依赖关系</p>
<p>​    这种依赖关系构成了构成一个环形调用。</p>
<p>单例可以解决，spring利用三级缓存，让bean提前暴露</p>
<ul>
<li>Spring 内部有三级缓存：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- Map&lt;String,Object&gt; singletonObjects 一级缓存，用于保存实例化、注入、初始化完成的bean实例</span><br><span class="line">- Map&lt;String,Object&gt; earlySingletonObjects 二级缓存，用于保存实例化完成但未初始化的bean实例</span><br><span class="line">- Map&lt;String,ObjectFactory&lt;?&gt; singletonFactories 三级缓存，用于保存bean创建工厂，以便于后面扩展有机会创建代理对象</span><br></pre></td></tr></table></figure>

<h4 id="Spring-Spring-MVC-Spring-Boot-之间什么关系"><a href="#Spring-Spring-MVC-Spring-Boot-之间什么关系" class="headerlink" title="Spring,Spring MVC,Spring Boot 之间什么关系"></a>Spring,Spring MVC,Spring Boot 之间什么关系</h4><p>Spring 包含了多个功能模块（上面刚刚提高过），其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块， Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块。</p>
<p>Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 <strong>MVC 架构</strong>的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p>
<p>使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。于是，Spring Boot 诞生了！Spring 旨在简化 J2EE 企业应用程序开发。Spring Boot 旨在简化 Spring 开发（减少配置文件，开箱即用！）。Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用！</p>
<h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><h4 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a><code>@SpringBootApplication</code></h4><p><code>@SpringBootApplication</code>是 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合。</p>
<p>三个注解的作用分别是：</p>
<ul>
<li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</li>
<li><code>@ComponentScan</code>： 扫描被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解默认会扫描该类所在的包下所有的类。</li>
<li><code>@Configuration</code>：允许在 Spring 上下文中注册额外的 bean 或导入其他配置类</li>
</ul>
<h4 id="Bean相关"><a href="#Bean相关" class="headerlink" title="Bean相关"></a>Bean相关</h4><h5 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired`"></a><strong>@Autowired`</strong></h5><p>自动导入对象到类中，被注入进的类同样要被 Spring 容器管理比如：Service 类注入到 Controller 类中。</p>
<h5 id="Component"><a href="#Component" class="headerlink" title="@Component"></a><strong>@Component</strong></h5><p><strong>,<code>@Repository</code>,<code>@Service</code>, `@Controller</strong>**</p>
<p>我们一般使用 <code>@Autowired</code> 注解让 Spring 容器帮我们自动装配 bean。要想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 bean 的类,可以采用以下注解实现：</p>
<ul>
<li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Spring中的dao，service，controller的区别或联系</span><br><span class="line">dao（数据访问层）：负责与数据打交道。通过Spring配置文件与数据库进行连接，封装了对数据库进行增删改查的基本操作。</span><br><span class="line">service（服务层）：建立在dao层上面，controller下面，提供服务。对一个dao或多个dao进行再次封装，封装成一个服务类。</span><br><span class="line">controller（业务层）：负责各个模块的管理控制；负责url映射地址。管理用户操作，根据用户请求来调用对应服务以便完成请求处理等；对service进行调用。</span><br><span class="line">其中dao与service层在开发中，需要先进行接口的设计，接着再设计实现接口的类。</span><br><span class="line">之所以这样会是因为会更符合MVC模式的理念，也符合大多数人的编程习惯，并且极大减少了开发的工作量，使其后期维护也较为轻松，更为重要的一点是可以极大地保障数据的安全，防止controller层对数据库直接进行操作。</span><br></pre></td></tr></table></figure>

<p><strong>@Component 和 @Bean 的区别是什么？</strong>`</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. @Component` 注解作用于类，而`@Bean`注解作用于方法。</span><br><span class="line">2. `@Component`通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用@ComponentScan`注解定义要扫描的路径从中找出标识了需要装配的类自动装配到Spring的bean容器中）。`@Bean`注解通常是我们在标有该注解的方法中定义产生这个 bean,`@Bean`告诉了Spring这是某个类的实例，当我需要用它的时候还给我。</span><br><span class="line">3. `@Bean` 注解比 `@Component` 注解的自定义性更强，而且很多地方我们只能通过 `@Bean` 注解来注册 bean。比如当我们引用第三方库中的类需要装配到Spring容器时，则只能通过 `@Bean`来实现。</span><br></pre></td></tr></table></figure>

<h5 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h5><p><code>@RestController</code>注解是@<strong>Controller</strong>和@<strong>ResponseBody</strong>的合集,表示这是个**控制器 bean,**并且是将函数的返回值直接填入 HTTP 响应体中,是 REST 风格的控制器。</p>
<p><em>Guide 哥：现在都是前后端分离，说实话我已经很久没有用过@Controller。如果你的项目太老了的话，就当我没说。</em>    ResponseBody将方法的返回值直接作为响应报文的响应体响应到浏览器（json，xml）。</p>
<p>单独使用 <code>@Controller</code> 不加 <code>@ResponseBody</code>的话一般是用在要返回一个视图的情况，这种情况属于比较传统的 Spring MVC 的应用，对应于前后端不分离的情况。<code>@Controller</code> +<code>@ResponseBody</code> 返回 <strong>JSON 或 XML</strong> 形式数据</p>
<h5 id="Scope"><a href="#Scope" class="headerlink" title="@Scope"></a><code>@Scope</code></h5><p>声明 Spring Bean 的作用域</p>
<h5 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a><code>@Configuration</code></h5><p>用来声明配置类，可以使用 <code>@Component</code>注解替代，不过使用<code>@Configuration</code>注解声明配置类更加语义化。</p>
<p>@Configuration本质上还是@Component。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration标记的类必须符合下面的要求：</span><br><span class="line">1.配置类不能是 final 类、都必须声明为static</span><br><span class="line">2.配置注解通常为了通过 @Bean 注解生成 Spring 容器管理的类，</span><br><span class="line">3.配置类必须是非本地的（即不能在方法中声明，不能是 private）。</span><br></pre></td></tr></table></figure>

<p><strong>Spring 容器在启动时,会加载默认的一些PostPRocessor,其中就有ConfigurationClassPostProcessor,</strong><br><strong>这个后置处理程序专门处理带有@Configuration注解的类,这个程序会在bean 定义加载完成后,在bean初始化前进行处理。</strong><br>【重要区别】</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Component:会当做配置类，但不会为其生成CGLIB代理class</span><br><span class="line">@Configuration:会当做配置类，但会为其生成CGLIB代理class</span><br><span class="line">在获取当前类名时，使用@Component获取的是当前类名；而@Configuration获取的是当前类名+唯一标识(CGLIB代理)</span><br></pre></td></tr></table></figure>

<h5 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h5><ol>
<li>@RequestMapping注解的<strong>功能</strong><br>从注解名称上我们可以看到，@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联<br>起来，建立映射关系。<br>SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。</li>
<li>@RequestMapping注解的<strong>位置</strong><br>@RequestMapping标识一个类：设置映射请求的请求路径的初始信息<br>@RequestMapping标识一个方法：设置映射请求请求路径的具体信息</li>
<li>@RequestMapping注解的<strong>value属性</strong><br>@RequestMapping注解的value属性通过请求的请求地址匹配请求映射<br>@RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址<br>所对应的请求<br>@RequestMapping注解的value属性必须设置，至少通过请求地址匹配请求映射</li>
<li>@RequestMapping注解的<strong>method属性</strong><br>@RequestMapping注解的method属性通过请求的请求方式（get或post）匹配请求映射<br>@RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配<br>多种请求方式的请求<br>若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错<br>405：Request method ‘POST’ not supported</li>
<li>@RequestMapping注解的<strong>params属性</strong><br>@RequestMapping注解的params属性通过请求的请求参数匹配请求映射<br>@RequestMapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数<br>和请求映射的匹配关系</li>
</ol>
<h4 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="@HTTP 请求"></a>@HTTP 请求</h4><p><strong>5 种常见的请求类型:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- GET ：请求从服务器获取特定资源。举个例子：`GET /users`（获取所有学生）</span><br><span class="line">- POST ：在服务器上创建一个新的资源。举个例子：`POST /users`（创建学生）</span><br><span class="line">- PUT ：更新服务器上的资源（客户端提供更新后的整个资源）。`PUT /users/12`（更新编号为 12 的学生）</span><br><span class="line">- DELETE ：从服务器删除特定的资源。举个例子：`DELETE /users/12`（删除编号为 12 的学生）</span><br><span class="line">- PATCH：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新），使用的比较少</span><br></pre></td></tr></table></figure>

<p><code>@GetMapping(&quot;users&quot;)</code> 等价于<code>@RequestMapping(value=&quot;/users&quot;,method=RequestMethod.GET)</code></p>
<p><code>@PostMapping(&quot;users&quot;)</code> 等价于<code>@RequestMapping(value=&quot;/users&quot;,method=RequestMethod.POST)</code></p>
<p><code>@PutMapping(&quot;/users/&#123;userId&#125;&quot;)</code> </p>
<p>@DeleteMapping(“/users/{userId}”)`</p>
<h4 id="前后端传值"><a href="#前后端传值" class="headerlink" title="@前后端传值"></a>@前后端传值</h4><p><strong>@PathVariable</strong></p>
<p>用于获取路径参数</p>
<p><strong>@RequestParam</strong></p>
<p><code>@RequestParam</code>用于获取查询参数。</p>
<p><strong>@RequestBody</strong></p>
<p>用于读取 Request 请求（可能是 POST,PUT,DELETE,GET 请求）的 body 部分并且<strong>Content-Type 为 application/json</strong> 格式的数据，接收到数据之后会自动将数据绑定到 Java 对象上去。系统会使用<code>HttpMessageConverter</code>或者自定义的<code>HttpMessageConverter</code>将请求的 body 中的 json 字符串转换为 java 对象。</p>
<p><strong>一个请求方法只可以有一个@RequestBody，但是可以有多个@RequestParam和@PathVariable</strong></p>
<p><strong>@RequestEntity</strong></p>
<p>RequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的<br>请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息</p>
<p><strong>@ResponseBody</strong></p>
<p>@ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到<br>浏览器</p>
<h4 id="读取配置信息"><a href="#读取配置信息" class="headerlink" title="@读取配置信息"></a>@读取配置信息</h4><p><strong>@Value</strong></p>
<p>使用 <code>@Value(&quot;$&#123;property&#125;&quot;)</code> 读取比较简单的配置信息：</p>
<p><strong>@ConfigurationProperties`(常用)</strong></p>
<p>通过<code>@ConfigurationProperties</code>读取配置信息并与 bean 绑定。</p>
<h4 id="参数校验注解"><a href="#参数校验注解" class="headerlink" title="@参数校验注解"></a>@参数校验注解</h4><p><strong>加在变量前</strong></p>
<ul>
<li><code>@NotEmpty</code> 被注释的字符串的不能为 null 也不能为空</li>
<li><code>@NotBlank</code> 被注释的字符串非 null，并且必须包含一个非验证请求体(RequestBody)空白字符</li>
<li><code>@Null</code> 被注释的元素必须为 null</li>
<li><code>@NotNull</code> 被注释的元素必须不为 null</li>
</ul>
<p><strong>验证请求体(RequestBody)</strong></p>
<p>在属性前添加</p>
<p>在需要验证的参数上加上了<code>@Valid</code>注解，如果验证失败，它将抛出<code>MethodArgumentNotValidException</code>。</p>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><h4 id="1、什么是MVC"><a href="#1、什么是MVC" class="headerlink" title="1、什么是MVC"></a>1、什么是MVC</h4><p>MVC是一种软件架构的思想，将软件按照<strong>模型、视图、控制器</strong>来划分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">M：Model，模型层，指工程中的JavaBean，作用是处理数据</span><br><span class="line">	JavaBean分为两类：</span><br><span class="line">	一类称为实体类Bean：专门存储业务数据的，如 Student、User 等</span><br><span class="line">	一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。</span><br><span class="line">V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据</span><br><span class="line">C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器</span><br></pre></td></tr></table></figure>

<p>MVC的工作流程： 用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller<br>调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果<br>找到相应的View视图，渲染数据后最终响应给浏览器</p>
<p>​    Controller—–&gt;Model——-&gt;Controller——-&gt;View</p>
<h4 id="2、什么是SpringMVC"><a href="#2、什么是SpringMVC" class="headerlink" title="2、什么是SpringMVC"></a>2、什么是SpringMVC</h4><p>Spring MVC是一个基于Java的实现了MVC设计模式的请求驱动类型的轻量级Web框架，通过把Model，View，Controller分离，将web层进行职责解耦，把复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。<br><strong>表述层</strong>开发的首选方案。<br>注：三层架构分为表述层（或表示层）controller、业务逻辑层service、数据访问层repository，表述层表示前台页面和后台。</p>
<h4 id="3、SpringMVC的特点"><a href="#3、SpringMVC的特点" class="headerlink" title="3、SpringMVC的特点"></a>3、SpringMVC的特点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.Spring 家族原生产品，与 IOC 容器等基础设施无缝对接</span><br><span class="line">2.基于原生的Servlet，通过了功能强大的前端控制器DispatcherServlet，对请求和响应进行统一处理</span><br><span class="line">3.表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案</span><br><span class="line">4.代码清新简洁，大幅度提升开发效率</span><br><span class="line">5.内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可</span><br><span class="line">6.性能卓著，尤其适合现代大型、超大型互联网项目要求</span><br></pre></td></tr></table></figure>

<h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><h4 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h4><p>通常搭建一个基于spring的web应用，我们需要做以下工作：</p>
<ol>
<li>pom文件中引入相关jar包，包括spring、<span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT1zcHJpbmdtdmMmc3BtPTEwMDEuMjEwMS4zMDAxLjcwMjA=">springmvc</span>、redis、mybaits、log4j、mysql-connector-java 等等相关jar …</li>
<li>配置web.xml，Listener配置、Filter配置、Servlet配置、<span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT1sb2c0aiZzcG09MTAwMS4yMTAxLjMwMDEuNzAyMA==">log4j</span>配置、error配置 …</li>
<li>配置数据库连接、配置spring事务</li>
<li>配置视图解析器</li>
<li>开启注解、自动扫描功能</li>
<li>配置完成后部署tomcat、启动调试</li>
</ol>
<p>在springboot中我们只需要引入下面简单的几步就可以完成一个ssm后台项目的初始搭建。</p>
<p>1、引入jar</p>
<p>spring-boot-starter-web包自动帮我们引入了web模块开发需要的相关jar包，</p>
<p>mybatis-spring-boot-starter帮我们引入了dao开发相关的jar包。</p>
<p>spring-boot-starter-xxx是官方提供的starter，xxx-spring-boot-starter是第三方提供的starter。</p>
<p>2、配置</p>
<ol>
<li>@Configuration&amp;与@Bean-&gt;基于java代码的bean配置</li>
<li>@Conditional-&gt;设置自动配置条件依赖</li>
<li>@EnableConfigurationProperties与@ConfigurationProperties-&gt;读取配置文件转换为bean。</li>
<li>@EnableAutoConfiguration、@AutoConfigurationPackage 与@Import-&gt;实现bean发现与加载。</li>
</ol>
<p>自动装配可以简单理解为：<strong>通过注解或者一些简单的配置就能在 Spring Boot 的帮助下实现某块功能。</strong></p>
<h4 id="SpringBoot-是如何实现自动装配的？"><a href="#SpringBoot-是如何实现自动装配的？" class="headerlink" title="SpringBoot 是如何实现自动装配的？"></a>SpringBoot 是如何实现自动装配的？</h4><p><code>@SpringBootApplication</code>看作是 <code>@Configuration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code> 注解的集合。根据 SpringBoot 官网，这三个注解的作用分别是：</p>
<ul>
<li><code>@EnableAutoConfiguration</code>：启用 SpringBoot 的自动配置机制</li>
<li><code>@Configuration</code>：允许在上下文中注册额外的 bean 或导入其他配置类</li>
<li><code>@ComponentScan</code>： 扫描被<code>@Component</code> (<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。</li>
</ul>
<p><strong>@EnableAutoConfiguration:实现自动装配的核心注解</strong></p>
<p><code>EnableAutoConfiguration</code> 只是一个简单地注解，自动装配核心功能的实现实际是通过 <code>AutoConfigurationImportSelector</code>类。</p>
<p> <strong>AutoConfigurationImportSelector:加载自动装配类</strong></p>
<p>实现了 <code>ImportSelector</code>接口，也就实现了这个接口中的 <code>selectImports</code>方法，该方法主要用于<strong>获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中</strong>。</p>
<ol>
<li>判断自动装配开关是否打开。默认<code>spring.boot.enableautoconfiguration=true</code>，可在 <code>application.properties</code> 或 <code>application.yml</code> 中设置</li>
<li>用于获取<code>EnableAutoConfiguration</code>注解中的 <code>exclude</code> 和 <code>excludeName</code>。</li>
<li>获取需要自动装配的所有配置类，读取<code>META-INF/spring.factories</code></li>
<li><code>@ConditionalOnXXX</code> 中的所有条件都满足，该类才会生效。</li>
</ol>
<h4 id="如何实现一个-Starter"><a href="#如何实现一个-Starter" class="headerlink" title="如何实现一个 Starter"></a>如何实现一个 Starter</h4><ol>
<li>创建<code>threadpool-spring-boot-starter</code>工程</li>
<li>引入 Spring Boot 相关依赖</li>
<li>创建<code>ThreadPoolAutoConfiguration</code></li>
<li>在<code>threadpool-spring-boot-starter</code>工程的 resources 包下创建<code>META-INF/spring.factories</code>文件</li>
<li>最后新建工程引入<code>threadpool-spring-boot-starter</code></li>
</ol>
<p><strong>Spring Boot 通过<code>@EnableAutoConfiguration</code>开启自动装配，通过 SpringFactoriesLoader 最终加载<code>META-INF/spring.factories</code>中的自动配置类实现自动装配，自动配置类其实就是通过<code>@Conditional</code>按需加载的配置类，想要其生效必须引入<code>spring-boot-starter-xxx</code>包实现起步依赖</strong>、</p>
<h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p>
<p>jdbc缺点：</p>
<p>1.在创建connection的时候，存在硬编码问题（也就是直接把连接信息写死，不方便后期维护）</p>
<p>2.preparedStatement对象在执行sql语句的时候存在硬编码问题。</p>
<p>3.每次在进行一次数据库连接后都会关闭数据库连接，频繁的开启/关闭数据连接影响性能。</p>
<p>简单的说一下mybatis相对jdbc的优势：</p>
<p>1.mybatis是把连接数据库的信息都是写在配置文件中，因此不存在硬编码问题，方便后期维护。</p>
<p>2.mybatis执行的sql语句都是通过配置文件进行配置，不需要写在java代码中。</p>
<p>3.mybatis的连接池管理、缓存管理等让连接数据库和查询数据效率更高。</p>
<h4 id="Mybatis全局配置文件"><a href="#Mybatis全局配置文件" class="headerlink" title="Mybatis全局配置文件"></a>Mybatis全局配置文件</h4><p>SqlMapConfig.xml是Mybatis的全局配置文件，它的名称可以是任意，但是一般命名都为（SqlMapConfig）</p>
<p><strong>properties标签：</strong></p>
<p>Mybatis可以通过该标签来读取java配置信息：</p>
<p>例如在工程中对数据源信息写在db.properties文件中，可以通过properties标签来加载该文件。</p>
<p><strong>SqlMapConfig.xml使用properties标签</strong></p>
<p>注意：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、 先加载properties中property标签声明的属性</span><br><span class="line">因此在property中的name属性的值和value比properties中的resource属性先加载。后加载的db.properties会覆盖于property加载属性和值。</span><br><span class="line">&lt;properties resource=&quot;db.properties&quot;&gt;</span><br><span class="line">​    &lt;property name=&quot;db.username&quot;,value=&quot;1234&quot;/&gt;</span><br><span class="line">&lt;/properties&gt;  </span><br><span class="line">2、 再加载properties标签引入的java配置文件中的属性</span><br><span class="line">3、 parameterType的值会和properties的属性值发生冲突。因此，在properties文件里的内容命名最好加上db.代表是跟数据源相关的属性，这样就不容易跟以后的属性发生冲突。</span><br></pre></td></tr></table></figure>

<p><strong>settings标签：</strong></p>
<p>该标签时mybatis的全局设置，该设置会影响mybatis的运行。</p>
<p>一般我们使用使用该标签来开启二级缓存和懒加载。</p>
<p><strong>typeAliases标签</strong></p>
<p>该标签是对po类进行别名设置，这样，在后面使用po类的时候就可以直接通过别名引用，而不需要通过po类的全限定名来引用。这样可以提高我们的开发效率。</p>
<p><strong>mappers标签</strong></p>
<p>该标签的作用是加载映射文件</p>
<h4 id="映射文件"><a href="#映射文件" class="headerlink" title="映射文件"></a>映射文件</h4><p><u>Xml 映射文件中，除了常见的 select|insert|update|delete 标签之外，还有哪些标签？</u></p>
<p>答：还有很多其他的标签， <code>&lt;resultMap&gt;</code> 、 <code>&lt;parameterMap&gt;</code> 、 <code>&lt;sql&gt;</code> 、 <code>&lt;include&gt;</code> 、 <code>&lt;selectKey&gt;</code> ，加上动态 sql 的 9 个标签， <code>trim|where|set|foreach|if|choose|when|otherwise|bind</code> 等，其中 <code>&lt;sql&gt;</code> 为 sql 片段标签，通过 <code>&lt;include&gt;</code> 标签引入 sql 片段， <code>&lt;selectKey&gt;</code> 为不支持自增的主键生成策略标签。</p>
<p><strong>输入映射parameterType</strong></p>
<p>第一种：简单类型</p>
<p>#{}表示占位符?，parameterType接收简单类型的参数时，里面的名称可以任意</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Integer&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">		SELECT * FROM USER WHERE id = #&#123;id&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>${}表示拼接符，parameterType接收简单类型的参数时，里面的名称必须是value</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findUsersByName&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.lc.mybatis.po.User&quot;</span>&gt;</span></span><br><span class="line">		SELECT * FROM USER WHERE username LIKE &quot;%$&#123;value&#125;%&quot;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第二种：pojo类型</p>
<p>第三种：包装类型pojo</p>
<p>第四种：map集合类型</p>
<p><strong>结果映射</strong></p>
<p><strong>resultType</strong>结果映射要求：需要查询结果的列名和映射的对象的属性名一致，这样才能映射成功。如果映射没成功也不会报错，只是映射结果中对象的相应属性没有值，为空。如果映射的列名和对象中的属性名全部不一致，那么映射的对象为空。如果在使用sql语句查询的时候给查询结果列设置了别名，则别名要和映射结果对象的属性名一致，这样才能保证映射成功。</p>
<p>使用<strong>resultMap</strong>结果映射时，不需要查询出来的结果集的列名和映射结果对象的属性名相同，但是需要声明一个resultMap，手动的方式来对列名和对象属性进行映射。（resultMap一般用于多表关联映射）</p>
<p><strong>动态sql</strong></p>
<p>在mybatis中提供了一些动态sql标签，可以让我们开发效率更快，这些动态sql语句可以增加我们写的sql语句的重用性，常用的动态sql语句标签有：if标签、sql片段(需要先定义后使用)、where标签、foreach标签</p>
<h4 id="Mapper接口的开发方式"><a href="#Mapper接口的开发方式" class="headerlink" title="Mapper接口的开发方式"></a><strong>Mapper接口的开发方式</strong></h4><p>该方式开发，不需要写dao层的实现类，而是mybatis根据映射文件等信息对接口进行jdk动态代理生成代理类来实现接口中的方法，因此，采用这种方式，我们只需要编辑接口，而不需要去写实现。</p>
<p><u>最佳实践中，通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？</u></p>
<p>答：Dao 接口，就是人们常说的 <code>Mapper</code> 接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中 <code>MappedStatement</code> 的 <strong>id</strong> 值，接口方法内的参数，就是传递给 sql 的参数。 <code>Mapper</code> 接口是没有实现类的，当调用接口方法时，<strong>接口全限名+方法名拼接字符串作为 key 值</strong>，可唯一定位一个 <code>MappedStatement</code> ，举例： <code>com.mybatis3.mappers. StudentDao.findStudentById</code> ，可以唯一找到 namespace 为 <code>com.mybatis3.mappers. StudentDao</code> 下面 <code>id = findStudentById</code> 的 <code>MappedStatement</code> 。在 MyBatis 中，每一个 <code>&lt;select&gt;</code> 、 <code>&lt;insert&gt;</code> 、 <code>&lt;update&gt;</code> 、 <code>&lt;delete&gt;</code> 标签，都会被解析为一个 <code>MappedStatement</code> 对象。</p>
<p><strong>Mybatis 的 Dao 接口可以有多个重载方法，但是多个接口对应的映射必须只有一个，否则启动会报错。</strong></p>
<p>Dao 接口方法可以重载，但是需要满足以下条件：</p>
<ol>
<li><p>仅有一个无参方法和一个有参方法</p>
</li>
<li><p>多个有参方法时，参数数量必须一致。且使用相同的 <code>@Param</code> ，或者使用 <code>param1</code> 这种</p>
</li>
</ol>
<h4 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{}和${}的区别"></a>#{}和${}的区别</h4><ol>
<li><strong>#{}</strong> <strong>是</strong> <strong>占位符</strong> <strong>：动态解析 -&gt; 预编译 -&gt; 执行</strong>，<strong>对应的变量会自动加上单引号</strong> ，<strong>能防止sql 注入</strong></li>
<li><strong>${}</strong> <strong>是</strong> <strong>拼接符</strong> <strong>：动态解析 -&gt; 编译 -&gt; 执行</strong>，<strong>对应的变量不会加上单引号</strong> ，<strong>不能防止sql 注入</strong></li>
</ol>
<p><strong>默认值不同</strong>。1 or 1=1</p>
<p>能用 #{} 的地方就用 #{}，尽量少用 ${}<br>表名作参数，或者order by 排序时用 ${}<br>传参时参数使用@Param(“”)注解，@Param注解的作用是给参数命名，参数命名后就能根据名字得到参数值（相当于又加了一层密），正确的将参数传入sql语句中（一般通过#{}的方式，${}会有sql注入的问题）。</p>
<p><code>&#123;&#125;</code>是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如${driver}会被静态替换为<code>com.mysql.jdbc. Driver</code>。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vanBmc3MvcC85NDQyMzcwLmh0bWw=">https://www.cnblogs.com/jpfss/p/9442370.html</span></p>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul>
<li><p><strong>工厂设计模式</strong> : Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</p>
<p><strong>两者对比：</strong></p>
<ul>
<li><code>BeanFactory</code> ：延迟注入(使用到某个 bean 的时候才会注入),相比于<code>BeanFactory</code>来说会占用更少的内存，程序启动速度更快。</li>
<li><code>ApplicationContext</code> ：容器启动的时候，不管你用没用到，一次性创建所有 bean 。<code>BeanFactory</code> 仅提供了最基本的依赖注入支持，<code>ApplicationContext</code> 扩展了 <code>BeanFactory</code> ,除了有<code>BeanFactory</code>的功能还有额外更多功能，所以一般开发人员使用<code>ApplicationContext</code>会更多。</li>
</ul>
</li>
<li><p><strong>代理设计模式</strong> : Spring AOP 功能的实现。<strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong></p>
</li>
<li><p><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</p>
</li>
<li><p><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</p>
<p>模板方法模式是一种行为设计模式，它定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。 模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤的实现方式。</p>
<p>包含抽象模板（父类）和具体模板（子类）实现。父类包含基本方法和模板方法，模板方法对具体方法调度。子类则对具体方法进行特定的实现。</p>
</li>
<li><p><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</p>
</li>
<li><p><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</p>
</li>
<li><p><strong>适配器模式</strong> : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</p>
</li>
</ul>

      <div class="tags">
          <a href="/tags/Java/" rel="tag"><i class="ic i-tag"></i> Java</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2022-04-11 12:26:04" itemprop="dateModified" datetime="2022-04-11T12:26:04+08:00">2022-04-11</time>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> Donate</button>
  <p>Give me a cup of [coffee]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wechatpay.png" alt="导弹哥 WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div>
        <img data-src="/images/alipay.png" alt="导弹哥 Alipay">
        <p>Alipay</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>导弹哥 <i class="ic i-at"><em>@</em></i>Hexo
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="http://example.com/2022/04/11/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%B0%8F%E8%AE%B0/" title="Spring全家桶速记">http://example.com/2022/04/11/Spring全家桶小记/</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2022/04/06/http%E5%8D%8F%E8%AE%AE%E5%B0%8F%E8%AE%B0/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicitf0kl1j20zk0m87fe.jpg" title="http协议小记">
  <span class="type">Previous Post</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>http协议小记</h3>
  </a>

    </div>
    <div class="item right">
    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IOC%E5%AE%B9%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text">IOC容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOP"><span class="toc-number">1.2.</span> <span class="toc-text">AOP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.3.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bean"><span class="toc-number">1.4.</span> <span class="toc-text">Bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">1.5.</span> <span class="toc-text">循环依赖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-Spring-MVC-Spring-Boot-%E4%B9%8B%E9%97%B4%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"><span class="toc-number">1.6.</span> <span class="toc-text">Spring,Spring MVC,Spring Boot 之间什么关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">常用注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringBootApplication"><span class="toc-number">2.1.</span> <span class="toc-text">@SpringBootApplication</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bean%E7%9B%B8%E5%85%B3"><span class="toc-number">2.2.</span> <span class="toc-text">Bean相关</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Autowired"><span class="toc-number">2.2.1.</span> <span class="toc-text">@Autowired&#96;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Component"><span class="toc-number">2.2.2.</span> <span class="toc-text">@Component</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RestController"><span class="toc-number">2.2.3.</span> <span class="toc-text">@RestController</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Scope"><span class="toc-number">2.2.4.</span> <span class="toc-text">@Scope</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Configuration"><span class="toc-number">2.2.5.</span> <span class="toc-text">@Configuration</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RequestMapping"><span class="toc-number">2.2.6.</span> <span class="toc-text">@RequestMapping</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-%E8%AF%B7%E6%B1%82"><span class="toc-number">2.3.</span> <span class="toc-text">@HTTP 请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%90%8E%E7%AB%AF%E4%BC%A0%E5%80%BC"><span class="toc-number">2.4.</span> <span class="toc-text">@前后端传值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF"><span class="toc-number">2.5.</span> <span class="toc-text">@读取配置信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.6.</span> <span class="toc-text">@参数校验注解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC"><span class="toc-number">3.</span> <span class="toc-text">SpringMVC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFMVC"><span class="toc-number">3.1.</span> <span class="toc-text">1、什么是MVC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFSpringMVC"><span class="toc-number">3.2.</span> <span class="toc-text">2、什么是SpringMVC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81SpringMVC%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">3.3.</span> <span class="toc-text">3、SpringMVC的特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBoot"><span class="toc-number">4.</span> <span class="toc-text">SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-number">4.1.</span> <span class="toc-text">自动装配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SpringBoot-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E7%9A%84%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">SpringBoot 是如何实现自动装配的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-Starter"><span class="toc-number">4.3.</span> <span class="toc-text">如何实现一个 Starter</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MyBatis"><span class="toc-number">5.</span> <span class="toc-text">MyBatis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mybatis%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">5.1.</span> <span class="toc-text">Mybatis全局配置文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="toc-number">5.2.</span> <span class="toc-text">映射文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mapper%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">Mapper接口的开发方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.4.</span> <span class="toc-text">#{}和${}的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">设计模式</span></a></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="导弹哥"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">导弹哥</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">4</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">1</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item email" data-url="bWFpbHRvOnlhbl94aWFuQGZveG1haWwuY29t" title="mailto:yan_xian@foxmail.com"><i class="ic i-envelope"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2022/04/06/http%E5%8D%8F%E8%AE%AE%E5%B0%8F%E8%AE%B0/" title="http协议小记">http协议小记</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2022/04/04/Map%E9%80%9F%E8%AE%B0/" title="Map速记">Map速记</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2022/04/11/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%B0%8F%E8%AE%B0/" title="Spring全家桶速记">Spring全家桶速记</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2022/02/04/%E5%B9%B6%E5%8F%91%E6%80%BB%E7%BB%93/" title="并发总结">并发总结</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>Recent Comments</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2022</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">导弹哥 @ 研究导弹茶叶蛋</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2022/04/11/Spring全家桶小记/',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,
    copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
